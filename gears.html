<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Gears</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
</head>

<body>
    <label for="src-teeth">Number of teeth in user-provided gear:</label>
    <input type="number" id="src-teeth" value="12" name="src-teeth">

    <label for="dst-teeth">Number of teeth in generated gear:</label>
    <input type="number" id="dst-teeth" value="12" name="dst-teeth">

    <label for="size">Size (in pixels) of generated gear:</label>
    <input type="number" id="size" value="400" name="size">
    
    <canvas id="canvas" width="1500" height="1500"></canvas>
    <script>
// TODO: create gear by calculating distance from center (polar coordinates) at each angle, instead of drawing and subtracting.

// https://learnersbucket.com/examples/algorithms/find-the-lcm-of-two-numbers-in-javascript/
let lcm = (n1, n2) => {
    let lar = Math.max(n1, n2);
    let small = Math.min(n1, n2);
    let i = lar;
    while (i % small !== 0) {
        i += lar;
    }
    return i;
}

const TAU = Math.PI * 2;

const STEPS_PER_TURN = 10000;
const FRAMES_PER_TURN = 100;

const canvas = document.getElementById("canvas");

let gearSrc;
async function makeGear(newSrc) {
    if (newSrc)
        gearSrc = newSrc;
    const SOURCE_TEETH = document.getElementById("src-teeth").valueAsNumber;
    const TARGET_TEETH = document.getElementById("dst-teeth").valueAsNumber;
    const gearRatio = TARGET_TEETH / SOURCE_TEETH;
    const TARGET_SIZE = document.getElementById("size").valueAsNumber;
    // Ensure enough contacts between the teeth.
    const LCM = lcm(SOURCE_TEETH, TARGET_TEETH);
    
    const TEETH_SIZE_FUDGE = 50;

    const ctx = canvas.getContext("2d");

    const gear = new Image();
    gear.src = gearSrc;
    await gear.decode();

    ctx.save();
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = "destination-out";
    let angle = 0;
    while (angle < 2 * TAU) {
        for (let i = 0; i < STEPS_PER_TURN / FRAMES_PER_TURN; i++) {
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(angle);
            ctx.translate(TARGET_SIZE / 2 - TEETH_SIZE_FUDGE, 0);
            ctx.translate(gear.width / 2, 0);
            ctx.rotate(angle * gearRatio);
            ctx.drawImage(gear, -gear.width / 2, -gear.height / 2);
            ctx.restore();
            angle += TAU / STEPS_PER_TURN;
        }
        await new Promise(resolve => requestAnimationFrame(resolve));
    }
    ctx.restore();

    // Save current canvas to draw in next frames.
    const targetGear = document.createElement("canvas");
    targetGear.width = TARGET_SIZE;
    targetGear.height = TARGET_SIZE;
    // Extract target gear from big canvas into cropped canvas.
    targetGear.getContext("2d").drawImage(canvas, canvas.width / 2 - TARGET_SIZE / 2, canvas.height / 2 - TARGET_SIZE / 2, TARGET_SIZE, TARGET_SIZE, 0, 0, TARGET_SIZE, TARGET_SIZE);

    while (true) {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.translate(canvas.width / 2, canvas.height / 2);

        ctx.save();
        ctx.rotate(angle / gearRatio);
        ctx.drawImage(targetGear, -TARGET_SIZE / 2, -TARGET_SIZE / 2);
        ctx.restore();

        ctx.save();
        ctx.translate(TARGET_SIZE / 2 - TEETH_SIZE_FUDGE, 0);
        ctx.translate(gear.width / 2, 0);
        ctx.rotate(-angle);
        ctx.drawImage(gear, -gear.width / 2, -gear.height / 2);
        ctx.restore();

        ctx.restore();
        angle += TAU / 1000;
        await new Promise(resolve => requestAnimationFrame(resolve));
    }
}

// TODO: this is broken because it starts a new infinite async process.
/*
document.getElementById("dst-teeth").addEventListener("input", () => {
    makeGear();
});
document.getElementById("src-teeth").addEventListener("input", () => {
    makeGear();
});
document.getElementById("size").addEventListener("input", () => {
    makeGear();
});
*/

canvas.addEventListener("dragover", (event) => {
    // prevent default to allow drop
    event.preventDefault();
});
canvas.addEventListener("drop", event => {
    event.preventDefault();
    // Draw dropped image to canvas.
    const reader = new FileReader();
    reader.readAsDataURL(event.dataTransfer.files[0]);
    reader.onload = () => {
        makeGear(reader.result);
    };
});

makeGear("gear.png");

    </script>
</body>

</html>